{"ast":null,"code":"/*\nThis function updates the Piece [] so that the piece moves to its new location. It\nalso handles the case where a piece is taken and when a ROOK is teleported via \nthe castling move.\n*/\nexport function executeMove(px, py, x, y, boardState) {\n  const takenPiece = boardState.find(p => p.taken === true);\n\n  if (takenPiece) {\n    takePiece(takenPiece, boardState);\n  } // const teleportedPiece = boardState.find(p => p.teleported === true)\n  // if (teleportedPiece){\n  //     teleportPiece(teleportedPiece)\n  // }\n\n\n  const currentPiece = boardState.find(p => p.x === px && p.y === py);\n\n  if (currentPiece) {\n    currentPiece.x = x;\n    currentPiece.y = y;\n  }\n}\n\nfunction takePiece(p, boardState) {\n  const id2 = boardState.indexOf(p);\n  boardState.splice(id2, 1);\n}\n\nfunction teleportPiece(p) {\n  let tele = 0;\n\n  if (p.x === 7) {\n    tele = -2;\n  } else {\n    tele = 3;\n  }\n\n  p.x = p.x + tele;\n  p.teleported = false;\n}","map":{"version":3,"sources":["/home/jaybird/Coding Projects/QuantumChess/quantum-chess/src/Referee/executeMove.ts"],"names":["executeMove","px","py","x","y","boardState","takenPiece","find","p","taken","takePiece","currentPiece","id2","indexOf","splice","teleportPiece","tele","teleported"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAMA,OAAO,SAASA,WAAT,CAAsBC,EAAtB,EAAmCC,EAAnC,EAAgDC,CAAhD,EAA4DC,CAA5D,EAAuEC,UAAvE,EAA6F;AAChG,QAAMC,UAAU,GAAGD,UAAU,CAACE,IAAX,CAAgBC,CAAC,IAAIA,CAAC,CAACC,KAAF,KAAY,IAAjC,CAAnB;;AACA,MAAIH,UAAJ,EAAe;AACXI,IAAAA,SAAS,CAACJ,UAAD,EAAaD,UAAb,CAAT;AACH,GAJ+F,CAKhG;AACA;AACA;AACA;;;AACA,QAAMM,YAAY,GAAGN,UAAU,CAACE,IAAX,CAAgBC,CAAC,IAAIA,CAAC,CAACL,CAAF,KAAQF,EAAR,IAAcO,CAAC,CAACJ,CAAF,KAAQF,EAA3C,CAArB;;AACA,MAAIS,YAAJ,EAAiB;AACbA,IAAAA,YAAY,CAACR,CAAb,GAAiBA,CAAjB;AACAQ,IAAAA,YAAY,CAACP,CAAb,GAAiBA,CAAjB;AACH;AACJ;;AAGD,SAASM,SAAT,CAAmBF,CAAnB,EAA8BH,UAA9B,EAAoD;AAChD,QAAMO,GAAG,GAAGP,UAAU,CAACQ,OAAX,CAAmBL,CAAnB,CAAZ;AACAH,EAAAA,UAAU,CAACS,MAAX,CAAkBF,GAAlB,EAAuB,CAAvB;AACH;;AAED,SAASG,aAAT,CAAuBP,CAAvB,EAAiC;AAC7B,MAAIQ,IAAI,GAAG,CAAX;;AACA,MAAIR,CAAC,CAACL,CAAF,KAAQ,CAAZ,EAAc;AACVa,IAAAA,IAAI,GAAG,CAAC,CAAR;AACH,GAFD,MAEO;AACHA,IAAAA,IAAI,GAAG,CAAP;AACH;;AACDR,EAAAA,CAAC,CAACL,CAAF,GAAMK,CAAC,CAACL,CAAF,GAAMa,IAAZ;AACAR,EAAAA,CAAC,CAACS,UAAF,GAAe,KAAf;AACH","sourcesContent":["/*\nThis function updates the Piece [] so that the piece moves to its new location. It\nalso handles the case where a piece is taken and when a ROOK is teleported via \nthe castling move.\n*/\n\n\n\nimport { Piece } from '../constants'\n\nexport function executeMove (px : number, py : number, x : number, y: number, boardState : Piece []){\n    const takenPiece = boardState.find(p => p.taken === true)\n    if (takenPiece){\n        takePiece(takenPiece, boardState)\n    }\n    // const teleportedPiece = boardState.find(p => p.teleported === true)\n    // if (teleportedPiece){\n    //     teleportPiece(teleportedPiece)\n    // }\n    const currentPiece = boardState.find(p => p.x === px && p.y === py) \n    if (currentPiece){\n        currentPiece.x = x\n        currentPiece.y = y\n    }\n}\n\n\nfunction takePiece(p : Piece, boardState : Piece []){\n    const id2 = boardState.indexOf(p)\n    boardState.splice(id2, 1)\n}\n\nfunction teleportPiece(p : Piece){\n    let tele = 0;\n    if (p.x === 7){  \n        tele = -2\n    } else {\n        tele = 3\n    }\n    p.x = p.x + tele\n    p.teleported = false\n}"]},"metadata":{},"sourceType":"module"}