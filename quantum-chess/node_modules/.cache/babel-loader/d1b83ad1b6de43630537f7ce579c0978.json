{"ast":null,"code":"/*\nThis class does a lot of the heavy lifting for the chess game.  Currently \nthe isValidMove also makes the move by changing the Piece [] as it checks for \nthe moves validity.  This is because once the move has been made it must use \nthe new board state to see if the move has put its own king in check which would \nactually make the move invalid.  So, if the move returns as invalid, the board \nstate must be reset. \n*/\nimport { PieceType, AXIS } from \"../constants\";\nimport { isPawnNormalMove, isPawnStartingMove, isFriendlyPiece } from \"./pawnLogic\";\nimport { isLegalBishopMove, isLegalRookMove, isLegalQueenMove, isLegalKingMove, isLegalNightMove } from \"./pieceLogic\";\nimport Checker from './checker';\nimport { CLICKED } from '../components/Promotion/promotion';\nimport { executeMove } from \"./executeMove\";\nexport default class Referee {\n  // promote(px: number, py: number, x : number, y: number, boardState : Piece []){\n  //     const piece = boardState.find(p => p.x === px && p.y === py)\n  //     if (piece && piece.type === PieceType.PAWN && piece.team === TeamType.WHITE && y === 7){\n  //         piece.promoted = true\n  //     }   \n  //     else if (piece && piece.type === PieceType.PAWN && piece.team === TeamType.BLACK && y === 0){\n  //         piece.promoted = true\n  //     } else if (piece){\n  //         piece.promoted = false\n  //     }\n  // } \n  takePiece(x, y, team, boardState) {\n    const piece = boardState.find(p => p.x === x && p.y === y && p.SuperPiece.team !== team);\n\n    if (piece) {\n      piece.taken = true;\n    }\n  }\n\n  endMove(px, py, x, y, team, boardState, valid, startingPawnMove, enPassant) {\n    if (!isFriendlyPiece(x, y, team, boardState)) {\n      executeMove(px, py, x, y, boardState);\n      const checker = new Checker(null);\n      console.log(team); // const inCheck = checker.isMyKingInCheck(team, boardState, 0)\n      // if (inCheck){\n      //     valid.value = false\n      // }  else {\n      //     valid.value = true\n      // }      \n    }\n  }\n\n  isValidMove(px, py, x, y, type, team, boardState, activePlayer) {\n    if (!CLICKED) {\n      return false;\n    } // Only the active player can move\n\n\n    if (team !== activePlayer) {\n      return false;\n    } // A non-move is not a move\n\n\n    if (px === x && py === y) {\n      return false;\n    } // A move off the board is not a move\n\n\n    if (!(AXIS.includes(px) && AXIS.includes(py) && AXIS.includes(x) && AXIS.includes(y))) {\n      return false;\n    }\n\n    var valid = {\n      value: false\n    };\n    const dx = x - px;\n    const dy = y - py;\n\n    switch (type) {\n      case PieceType.PAWN:\n        {\n          if (isPawnStartingMove(px, py, x, y, team, boardState)) {\n            this.endMove(px, py, x, y, team, boardState, valid, true, false);\n          }\n\n          if (isPawnNormalMove(px, py, x, y, team, boardState)) {\n            this.endMove(px, py, x, y, team, boardState, valid, false, false);\n          }\n\n          break;\n        }\n\n      case PieceType.NIGHT:\n        {\n          if (isLegalNightMove(px, py, dx, dy, boardState)) {\n            this.endMove(px, py, x, y, team, boardState, valid, false, false);\n          }\n\n          break;\n        }\n\n      case PieceType.BISHOP:\n        {\n          if (isLegalBishopMove(px, py, dx, dy, boardState)) {\n            this.endMove(px, py, x, y, team, boardState, valid, false, false);\n          }\n\n          break;\n        }\n\n      case PieceType.ROOK:\n        {\n          if (isLegalRookMove(px, py, dx, dy, boardState)) {\n            this.endMove(px, py, x, y, team, boardState, valid, false, false);\n          }\n\n          break;\n        }\n\n      case PieceType.QUEEN:\n        {\n          if (isLegalQueenMove(px, py, dx, dy, boardState)) {\n            this.endMove(px, py, x, y, team, boardState, valid, false, false);\n          }\n\n          break;\n        }\n\n      case PieceType.KING:\n        {\n          if (isLegalKingMove(px, py, dx, dy, boardState)) {\n            this.endMove(px, py, x, y, team, boardState, valid, false, false);\n          }\n\n          break;\n        }\n    }\n\n    return valid.value;\n  }\n\n}","map":{"version":3,"sources":["/home/jaybird/Coding Projects/QuantumChess/quantum-chess/src/Referee/referee.ts"],"names":["PieceType","AXIS","isPawnNormalMove","isPawnStartingMove","isFriendlyPiece","isLegalBishopMove","isLegalRookMove","isLegalQueenMove","isLegalKingMove","isLegalNightMove","Checker","CLICKED","executeMove","Referee","takePiece","x","y","team","boardState","piece","find","p","SuperPiece","taken","endMove","px","py","valid","startingPawnMove","enPassant","checker","console","log","isValidMove","type","activePlayer","includes","value","dx","dy","PAWN","NIGHT","BISHOP","ROOK","QUEEN","KING"],"mappings":"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","sourcesContent":["/*\nThis class does a lot of the heavy lifting for the chess game.  Currently \nthe isValidMove also makes the move by changing the Piece [] as it checks for \nthe moves validity.  This is because once the move has been made it must use \nthe new board state to see if the move has put its own king in check which would \nactually make the move invalid.  So, if the move returns as invalid, the board \nstate must be reset. \n*/\n\n\nimport { PieceType, TeamType, Piece, AXIS } from \"../constants\"\nimport { isPawnNormalMove, isPawnStartingMove, isFriendlyPiece } from \"./pawnLogic\"\nimport { isLegalBishopMove, isLegalRookMove, isLegalQueenMove, isLegalKingMove, isLegalNightMove} from \"./pieceLogic\"\nimport Checker from './checker'\nimport {CLICKED} from '../components/Promotion/promotion'\nimport { executeMove } from \"./executeMove\"\n\nexport default class Referee{\n    \n\n\n    // promote(px: number, py: number, x : number, y: number, boardState : Piece []){\n    //     const piece = boardState.find(p => p.x === px && p.y === py)\n    //     if (piece && piece.type === PieceType.PAWN && piece.team === TeamType.WHITE && y === 7){\n    //         piece.promoted = true\n    //     }   \n    //     else if (piece && piece.type === PieceType.PAWN && piece.team === TeamType.BLACK && y === 0){\n    //         piece.promoted = true\n    //     } else if (piece){\n    //         piece.promoted = false\n    //     }\n    // } \n\n    takePiece(x : number, y: number, team : TeamType, boardState : Piece []){\n        const piece = boardState.find(p => p.x === x && p.y === y && p.SuperPiece.team !== team)  \n                if (piece) {\n            piece.taken = true\n        }\n    }\n\n    endMove(px : number, py : number, x : number, y: number, team : TeamType, \n            boardState : Piece [], valid : any, startingPawnMove: boolean, enPassant: boolean){\n        if (!isFriendlyPiece(x, y, team, boardState)){\n            executeMove(px, py, x, y, boardState)\n            const checker = new Checker(null);\n            console.log(team)\n            // const inCheck = checker.isMyKingInCheck(team, boardState, 0)\n            // if (inCheck){\n            //     valid.value = false\n            // }  else {\n            //     valid.value = true\n            // }      \n        }\n    }\n    isValidMove(px : number, py : number, x : number, y : number, type : PieceType, \n                team : TeamType, boardState : Piece [],  activePlayer : TeamType) : boolean{\n        if (!CLICKED){\n            return false\n        }  \n        // Only the active player can move\n        if (team !== activePlayer){\n            return false\n        }\n        // A non-move is not a move\n        if (px === x && py === y){\n            return false\n        }\n        // A move off the board is not a move\n        if (!(AXIS.includes(px) &&  AXIS.includes(py) &&  AXIS.includes(x) && AXIS.includes(y))){\n            return false\n        }\n        var valid = { value: false }\n        const dx = x - px\n        const dy = y - py\n\n        switch(type){\n            case PieceType.PAWN : {\n                if (isPawnStartingMove(px, py, x, y, team, boardState)){\n                    this.endMove(px, py, x, y, team, boardState, valid, true, false)\n                }\n                if (isPawnNormalMove(px, py, x, y, team, boardState)){\n                    this.endMove(px, py, x, y, team, boardState, valid, false, false)\n                }\n                break;\n            }\n            case PieceType.NIGHT : {\n                if (isLegalNightMove(px, py, dx, dy, boardState)){\n                    this.endMove(px, py, x, y, team, boardState, valid, false, false)\n                }\n                break;\n            }\n            case PieceType.BISHOP : {\n                if (isLegalBishopMove(px, py, dx, dy, boardState)){\n                    this.endMove(px, py, x, y, team, boardState, valid, false, false)\n                }\n                break;\n            }\n            case PieceType.ROOK : {\n                if (isLegalRookMove(px, py, dx, dy, boardState)){\n                    this.endMove(px, py, x, y, team, boardState, valid, false, false)\n                }\n                break;\n            }\n            case PieceType.QUEEN : {\n                if (isLegalQueenMove(px, py, dx, dy, boardState)){\n                    this.endMove(px, py, x, y, team, boardState, valid, false, false)\n                }\n                break;\n            }\n            case PieceType.KING : {\n                if (isLegalKingMove(px, py, dx, dy, boardState)){\n                    this.endMove(px, py, x, y, team, boardState, valid, false, false)\n                }\n                break;\n            }\n\n        }\n    return valid.value\n    }\n}"]},"metadata":{},"sourceType":"module"}