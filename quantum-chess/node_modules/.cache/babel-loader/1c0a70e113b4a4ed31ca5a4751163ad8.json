{"ast":null,"code":"export function pawnIsBlockaded(x, y, boardState) {\n  const piece = boardState.find(p => p.x === x && p.y === y);\n  const occupied = piece ? true : false;\n  return occupied;\n}\nexport function setEnPassant(px, py, boardState) {\n  boardState.forEach(p => {\n    if (p.x === px && p.y === py) {\n      p.enPassantable = true;\n    } else {\n      p.enPassantable = false;\n    }\n  });\n}\nexport function checkEnPassant(x, y, boardState) {\n  const piece = boardState.find(p => p.x === x && p.y === y);\n\n  if (piece && piece.enPassantable) {\n    return piece.enPassantable;\n  }\n\n  return false;\n}\nexport function unsetEnPassant(boardState) {\n  boardState.forEach(p => {\n    p.enPassantable = false;\n  });\n}\nexport function isPawnSpecialMove() {\n  if (py === startingRow && px === x && py === y - 2 * increment) {\n    if (!pawnIsBlockaded(x, y, boardState) && !pawnIsBlockaded(x, y - increment, boardState)) {\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/jaybird/Coding Projects/Chess4/chess/src/referee/pawnLogic.ts"],"names":["pawnIsBlockaded","x","y","boardState","piece","find","p","occupied","setEnPassant","px","py","forEach","enPassantable","checkEnPassant","unsetEnPassant","isPawnSpecialMove","startingRow","increment"],"mappings":"AAIA,OAAO,SAASA,eAAT,CAAyBC,CAAzB,EAAqCC,CAArC,EAAgDC,UAAhD,EAAgF;AACnF,QAAMC,KAAK,GAAGD,UAAU,CAACE,IAAX,CAAgBC,CAAC,IAAIA,CAAC,CAACL,CAAF,KAAQA,CAAR,IAAaK,CAAC,CAACJ,CAAF,KAAQA,CAA1C,CAAd;AACA,QAAMK,QAAQ,GAAIH,KAAK,GAAG,IAAH,GAAU,KAAjC;AACA,SAAOG,QAAP;AACH;AAED,OAAO,SAASC,YAAT,CAAsBC,EAAtB,EAAmCC,EAAnC,EAAgDP,UAAhD,EAAsE;AACrEA,EAAAA,UAAU,CAACQ,OAAX,CAAmBL,CAAC,IAAI;AACpB,QAAIA,CAAC,CAACL,CAAF,KAAQQ,EAAR,IAAcH,CAAC,CAACJ,CAAF,KAAQQ,EAA1B,EAA6B;AACzBJ,MAAAA,CAAC,CAACM,aAAF,GAAkB,IAAlB;AACH,KAFD,MAEM;AACFN,MAAAA,CAAC,CAACM,aAAF,GAAkB,KAAlB;AACH;AACJ,GAND;AAOH;AAEL,OAAO,SAASC,cAAT,CAAyBZ,CAAzB,EAAqCC,CAArC,EAAiDC,UAAjD,EAAkF;AACrF,QAAMC,KAAK,GAAGD,UAAU,CAACE,IAAX,CAAgBC,CAAC,IAAIA,CAAC,CAACL,CAAF,KAAQA,CAAR,IAAaK,CAAC,CAACJ,CAAF,KAAQA,CAA1C,CAAd;;AACA,MAAIE,KAAK,IAAIA,KAAK,CAACQ,aAAnB,EAAiC;AAC7B,WAAOR,KAAK,CAACQ,aAAb;AACH;;AAAC,SAAO,KAAP;AACL;AAED,OAAO,SAASE,cAAT,CAAyBX,UAAzB,EAA+C;AAClDA,EAAAA,UAAU,CAACQ,OAAX,CAAmBL,CAAC,IAAI;AAChBA,IAAAA,CAAC,CAACM,aAAF,GAAkB,KAAlB;AACP,GAFD;AAGH;AAED,OAAO,SAASG,iBAAT,GAAoC;AACvC,MAAKL,EAAE,KAAKM,WAAP,IAAsBP,EAAE,KAAKR,CAA9B,IAAqCS,EAAE,KAAKR,CAAC,GAAG,IAAIe,SAAxD,EAAmE;AAC/D,QAAI,CAACjB,eAAe,CAACC,CAAD,EAAIC,CAAJ,EAAOC,UAAP,CAAhB,IAAsC,CAACH,eAAe,CAACC,CAAD,EAAIC,CAAC,GAAGe,SAAR,EAAmBd,UAAnB,CAA1D,EAAyF;AACrF,aAAO,IAAP;AACH;AACJ;;AAAC,SAAO,KAAP;AACL","sourcesContent":["import { Piece } from '../constants'\n\n\n\nexport function pawnIsBlockaded(x : number, y: number, boardState : Piece []): boolean {\n    const piece = boardState.find(p => p.x === x && p.y === y) \n    const occupied =  piece ? true : false\n    return occupied\n}\n\nexport function setEnPassant(px : number, py : number, boardState : Piece []){\n        boardState.forEach(p => {\n            if (p.x === px && p.y === py){\n                p.enPassantable = true\n            } else{\n                p.enPassantable = false\n            }\n        })\n    }\n\nexport function checkEnPassant (x : number, y : number, boardState : Piece []) : boolean {\n    const piece = boardState.find(p => p.x === x && p.y === y)\n    if (piece && piece.enPassantable){\n        return piece.enPassantable  \n    } return false\n}\n\nexport function unsetEnPassant( boardState : Piece []){\n    boardState.forEach(p => {\n            p.enPassantable = false\n    })\n}\n\nexport function isPawnSpecialMove():boolean{\n    if ((py === startingRow && px === x) && (py === y - 2 * increment)){\n        if (!pawnIsBlockaded(x, y, boardState) && !pawnIsBlockaded(x, y - increment, boardState)){\n            return true\n        }\n    } return false\n}"]},"metadata":{},"sourceType":"module"}