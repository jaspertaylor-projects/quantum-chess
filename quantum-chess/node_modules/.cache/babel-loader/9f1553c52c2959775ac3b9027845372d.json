{"ast":null,"code":"/*\nThis is the file where we detrmine whether Kings are in check or checkmate.  It\nis important to remember that the isCheckMate function works by checking to see\nif there are any legal moves for a piece and returns true if there are no moves\nsometimes this can be stale mate so it must be used in conjunction with \nisMyKingInCheck to fully determine the outcome of the game.\n\n*/\nimport { PieceType, TeamType } from \"../constants\";\nimport { CLICKED1 } from '../components/Promotion/promotion';\nimport { CLICKED2 } from '../components/TakePiece/TakePiece';\nimport Referee from './referee';\nimport { AXIS } from '../constants';\nimport { fakeMove } from \"./executeMove\";\nexport default class Checker {\n  constructor(boardState) {\n    this.oldBoardState = void 0;\n    this.oldBoardState = boardState;\n  } // Makes a copy of the board state so that way we can make 'hypothetical'\n  // moves and then do a 'take back'.\n\n\n  deepCopy(boardState) {\n    if (this.oldBoardState) {\n      for (let i = 0; i < this.oldBoardState.length; i++) {\n        const p = this.oldBoardState[i];\n        boardState[i] = {\n          SuperPiece: p.SuperPiece,\n          x: p.x,\n          y: p.y,\n          taken: false,\n          promoted: false\n        };\n      }\n    }\n  }\n\n  removeKing(p) {\n    if (p.SuperPiece.subPieces.includes(PieceType.KING)) {\n      p.SuperPiece.subPieces.splice(0, 1);\n    }\n  }\n\n  removeKingsInCheck(boardState, team) {\n    const ref = new Referee();\n    const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE;\n\n    for (let i = 0; i < boardState.length; i++) {\n      const enemyPiece = boardState[i];\n\n      if (enemyPiece.SuperPiece.team === enemyTeam) {\n        for (let j = 0; j < boardState.length; j++) {\n          const ourPiece = boardState[j];\n\n          if (ourPiece.SuperPiece.team === team && ourPiece.SuperPiece.subPieces.length > 1) {\n            const piecesThatCanTakeMyKing = ref.getPossiblePieces(enemyPiece.x, enemyPiece.y, ourPiece.x, ourPiece.y, enemyPiece.SuperPiece, boardState, enemyTeam);\n\n            if (piecesThatCanTakeMyKing.length > 0) {\n              this.removeKing(ourPiece);\n            }\n          }\n        }\n      }\n    }\n  } // Returns true if your team has a king in check.  The increment should usually be set to 0 \n  // but exists for checking the no castling through check rule \n\n\n  isMyKingInCheck(team, boardState) {\n    const ref = new Referee();\n    const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE;\n    const myKing = boardState.find(p => p.SuperPiece.team === team && p.SuperPiece.subPieces.length === 1 && p.SuperPiece.subPieces[0] === PieceType.KING);\n\n    if (myKing) {\n      for (let i = 0; i < boardState.length; i++) {\n        const p = boardState[i];\n\n        if (p.SuperPiece.team === enemyTeam) {\n          const piecesThatCanTakeMyKing = ref.getPossiblePieces(p.x, p.y, myKing.x, myKing.y, p.SuperPiece, boardState, enemyTeam);\n\n          if (piecesThatCanTakeMyKing.length > 0) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  } //Returns true if the enemy team has no legal moves\n\n\n  isCheckMate(team, boardState) {\n    const CLICKED = CLICKED1 && CLICKED2;\n    const ref = new Referee();\n    const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE;\n\n    for (let j = AXIS.length - 1; j >= 0; j--) {\n      for (let i = 0; i < AXIS.length; i++) {\n        for (let k = 0; k < boardState.length; k++) {\n          const p = boardState[k];\n\n          if (p.SuperPiece.team === enemyTeam) {\n            const legalMove = ref.getPossiblePieces(p.x, p.y, i, j, p.SuperPiece, boardState, enemyTeam);\n\n            if (legalMove.length > 0 || !CLICKED) {\n              fakeMove(p.x, p.y, i, j, legalMove, enemyTeam, boardState);\n              const inCheck = this.isMyKingInCheck(enemyTeam, boardState);\n              this.deepCopy(boardState);\n\n              if (!inCheck) {\n                return false;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n}","map":{"version":3,"sources":["/home/jaybird/Coding Projects/QuantumChessV2/quantum-chess/src/Referee/checker.ts"],"names":["PieceType","TeamType","CLICKED1","CLICKED2","Referee","AXIS","fakeMove","Checker","constructor","boardState","oldBoardState","deepCopy","i","length","p","SuperPiece","x","y","taken","promoted","removeKing","subPieces","includes","KING","splice","removeKingsInCheck","team","ref","enemyTeam","WHITE","BLACK","enemyPiece","j","ourPiece","piecesThatCanTakeMyKing","getPossiblePieces","isMyKingInCheck","myKing","find","isCheckMate","CLICKED","k","legalMove","inCheck"],"mappings":"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","sourcesContent":["/*\nThis is the file where we detrmine whether Kings are in check or checkmate.  It\nis important to remember that the isCheckMate function works by checking to see\nif there are any legal moves for a piece and returns true if there are no moves\nsometimes this can be stale mate so it must be used in conjunction with \nisMyKingInCheck to fully determine the outcome of the game.\n\n*/\n\n\nimport { PieceType, TeamType, Piece} from \"../constants\"\nimport { isLegalBishopMove, isLegalRookMove, isLegalQueenMove, isLegalKingMove, isLegalNightMove, isWH, isWD} from \"./pieceLogic\"\nimport { isPawnNormalMove } from \"./pawnLogic\"\nimport { CLICKED1 } from '../components/Promotion/promotion'\nimport { CLICKED2 } from '../components/TakePiece/TakePiece'\nimport Referee from './referee'\nimport { AXIS } from '../constants'\nimport { fakeMove } from \"./executeMove\"\n\nexport default class Checker {   \n    oldBoardState : Piece [] | null;\n\n    constructor (boardState: Piece [] | null){\n        this.oldBoardState = boardState\n    }\n\n    // Makes a copy of the board state so that way we can make 'hypothetical'\n    // moves and then do a 'take back'.\n    deepCopy(boardState : Piece []) {\n        if (this.oldBoardState){\n            for (let i = 0; i < this.oldBoardState.length; i ++){\n                const p = this.oldBoardState[i]\n                boardState[i] = {SuperPiece : p.SuperPiece, x : p.x, y : p.y, taken : false, promoted : false}\n            }\n        }\n    } \n    removeKing(p : Piece){\n        if (p.SuperPiece.subPieces.includes(PieceType.KING)){\n            p.SuperPiece.subPieces.splice(0, 1)\n        }\n    }\n\n    removeKingsInCheck(boardState : Piece [], team : TeamType){\n        const ref = new Referee()\n        const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE\n        for (let i = 0; i < boardState.length; i++){\n            const enemyPiece = boardState[i];\n            if (enemyPiece.SuperPiece.team === enemyTeam){\n                for (let j = 0; j < boardState.length; j++){\n                    const ourPiece = boardState[j];\n                    if (ourPiece.SuperPiece.team === team && ourPiece.SuperPiece.subPieces.length > 1){\n                        const piecesThatCanTakeMyKing = ref.getPossiblePieces(enemyPiece.x, enemyPiece.y, ourPiece.x, \n                                                                            ourPiece.y, enemyPiece.SuperPiece, boardState,  \n                                                                            enemyTeam)\n                        if (piecesThatCanTakeMyKing.length > 0){\n                            this.removeKing(ourPiece)\n                        }\n                    }\n\n                }\n            } \n        }\n    }\n    // Returns true if your team has a king in check.  The increment should usually be set to 0 \n    // but exists for checking the no castling through check rule \n    isMyKingInCheck(team : TeamType, boardState : Piece []) : boolean {\n        const ref = new Referee()\n        const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE\n        const myKing = boardState.find(p => p.SuperPiece.team === team \n                                        && p.SuperPiece.subPieces.length === 1\n                                        && p.SuperPiece.subPieces[0] === PieceType.KING) \n        if (myKing){ \n            for (let i = 0; i < boardState.length; i++){\n                const p = boardState[i];\n                if (p.SuperPiece.team === enemyTeam) {\n                    const piecesThatCanTakeMyKing = ref.getPossiblePieces(p.x, p.y, myKing.x, myKing.y, p.SuperPiece, boardState,  enemyTeam)\n                    if (piecesThatCanTakeMyKing.length > 0){\n                        return true\n                    }\n                }\n            }\n        }\n        return false    \n        }\n\n\n    //Returns true if the enemy team has no legal moves\n    isCheckMate(team : TeamType, boardState : Piece []): boolean{\n        const CLICKED = CLICKED1 && CLICKED2\n        const ref = new Referee()\n        const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE\n        for (let j = AXIS.length - 1; j >= 0; j-- ){\n            for (let i = 0; i < AXIS.length; i++ ) {\n                for (let k = 0; k < boardState.length; k ++ ){\n                    const p = boardState[k] \n                    if (p.SuperPiece.team === enemyTeam)  {               \n                        const legalMove = ref.getPossiblePieces(p.x, p.y, i, j,  p.SuperPiece, boardState, enemyTeam)\n                        if (legalMove.length > 0|| !CLICKED){\n                            fakeMove(p.x, p.y, i, j,  legalMove, enemyTeam, boardState)\n                            const inCheck = this.isMyKingInCheck(enemyTeam, boardState)\n                            this.deepCopy(boardState)\n                            if (!inCheck){\n                                return false   \n                            }                   \n                        } \n                    }\n                }\n            \n            }\n        }        \n        return true\n\n    }\n\n}"]},"metadata":{},"sourceType":"module"}