{"ast":null,"code":"/*\nThis is the file where we detrmine whether Kings are in check or checkmate.  It\nis important to remember that the isCheckMate function works by checking to see\nif there are any legal moves for a piece and returns true if there are no moves\nsometimes this can be stale mate so it must be used in conjunction with \nisMyKingInCheck to fully determine the outcome of the game.\n\n*/\nimport { PieceType, TeamType } from \"../constants\";\nimport { isLegalBishopMove, isLegalRookMove, isLegalQueenMove, isLegalKingMove, isLegalNightMove } from \"./pieceLogic\";\nimport { isPawnNormalMove } from \"./pawnLogic\";\nexport default class Checker {\n  constructor(boardState) {\n    this.oldBoardState = void 0;\n    this.oldBoardState = boardState;\n  } // Makes a copy of the board state so that way we can make 'hypothetical'\n  // moves and then do a 'take back'.\n\n\n  deepCopy(boardState) {\n    if (this.oldBoardState) {\n      for (let i = 0; i < this.oldBoardState.length; i++) {\n        const p = this.oldBoardState[i];\n        boardState[i] = {\n          SuperPiece: p.SuperPiece,\n          x: p.x,\n          y: p.y,\n          taken: false,\n          promoted: false\n        };\n      }\n    }\n  }\n\n  removeKing(p) {\n    if (p.SuperPiece.subPieces.includes(PieceType.KING)) {\n      p.SuperPiece.subPieces.splice(0, 1);\n    }\n  }\n\n  removeKingsInCheck(boardState, team) {\n    const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE;\n\n    for (let i = 0; i < boardState.length; i++) {\n      const enemyPiece = boardState[i];\n\n      if (enemyPiece.SuperPiece.team === enemyTeam) {\n        for (let j = 0; j < boardState.length; j++) {\n          const ourPiece = boardState[j];\n\n          if (ourPiece.SuperPiece.team === team) {\n            const dx = ourPiece.x - enemyPiece.x;\n            const dy = ourPiece.y - enemyPiece.y;\n\n            switch (enemyPiece.SuperPiece.checksLike) {\n              case PieceType.PAWN:\n                {\n                  if (isPawnNormalMove(enemyPiece.x, enemyPiece.y, ourPiece.x, ourPiece.y, team, boardState)) {\n                    this.removeKing(ourPiece);\n                  }\n\n                  break;\n                }\n\n              case PieceType.NIGHT:\n                {\n                  console.log('OMG IM HERE');\n\n                  if (isLegalNightMove(enemyPiece.x, enemyPiece.y, dx, dy, boardState)) {\n                    this.removeKing(ourPiece);\n                  }\n\n                  break;\n                }\n\n              case PieceType.BISHOP:\n                {\n                  if (isLegalBishopMove(enemyPiece.x, enemyPiece.y, dx, dy, boardState)) {\n                    this.removeKing(ourPiece);\n                  }\n\n                  break;\n                }\n\n              case PieceType.ROOK:\n                {\n                  if (isLegalRookMove(enemyPiece.x, enemyPiece.y, dx, dy, boardState)) {\n                    this.removeKing(ourPiece);\n                  }\n\n                  break;\n                }\n\n              case PieceType.QUEEN:\n                {\n                  if (isLegalQueenMove(enemyPiece.x, enemyPiece.y, dx, dy, boardState)) {\n                    this.removeKing(ourPiece);\n                  }\n\n                  break;\n                }\n\n              case PieceType.KING:\n                {\n                  if (isLegalKingMove(enemyPiece.x, enemyPiece.y, dx, dy, boardState)) {\n                    this.removeKing(ourPiece);\n                  }\n\n                  break;\n                }\n            }\n          }\n        }\n      }\n    }\n  } // // Returns true if your team has a king in check.  The increment should usually be set to 0 \n  // // but exists for checking the no castling through check rule \n  // isMyKingInCheck(team : TeamType, boardState : Piece [], increment : number) : boolean {\n  //     const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE\n  //     const myKing = boardState.find(p => p.SuperPiece.team === team && p.type === PieceType.KING) \n  //     for (let i = 0; i < boardState.length; i++){\n  //         const p = boardState[i];\n  //         if (myKing && p.SuperPiece.team === enemyTeam) {\n  //             const dx = myKing.x + increment - p.x\n  //             const dy = myKing.y - p.y\n  //             switch (p.type){\n  //                 case PieceType.PAWN : {\n  //                     if (isPawnNormalMove(p.x, p.y, myKing.x + increment, myKing.y, p.team, boardState)){\n  //                         return true;\n  //                     } break;\n  //                 }\n  //                 case PieceType.NIGHT : {\n  //                     if (isLegalNightMove(p.x, p.y, dx, dy, boardState)){\n  //                         return true;\n  //                     } break;\n  //                 }\n  //                 case PieceType.BISHOP : {\n  //                     if (isLegalBishopMove(p.x, p.y, dx, dy, boardState)){\n  //                         return true;\n  //                     } break;\n  //                 }\n  //                 case PieceType.ROOK : {\n  //                     if (isLegalRookMove(p.x, p.y, dx, dy, boardState)){\n  //                         return true;\n  //                     } break;\n  //                 }\n  //                 case PieceType.QUEEN : {\n  //                     if (isLegalQueenMove(p.x, p.y, dx, dy, boardState)){\n  //                         return true;\n  //                     } break;\n  //                 }\n  //                 case PieceType.KING : {\n  //                     if (isLegalKingMove(p.x, p.y, dx, dy, boardState)){\n  //                         return true;\n  //                     } break;\n  //                 }\n  //             }\n  //         }\n  //     }\n  //     return false\n  // }\n  // Returns true if the enemy team has no legal moves\n  //     isCheckMate(team : TeamType, boardState : Piece []): boolean{\n  //         const ref = new Referee()\n  //         const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE\n  //         for (let j = VERTICAL_AXIS.length - 1; j >= 0; j-- ){\n  //             for (let i = 0; i < HORIZONTAL_AXIS.length; i++ ) {\n  //                 for (let k = 0; k < boardState.length; k ++ ){\n  //                     const p = boardState[k] \n  //                     if (p.SuperPiece.team === enemyTeam)  {               \n  //                         const legalMove = ref.isValidMove(p.x, p.y, i, j,  p.type, enemyTeam, boardState, enemyTeam)\n  //                         this.deepCopy(boardState)\n  //                         if (legalMove || !CLICKED){\n  //                             return false                       \n  //                         } \n  //                     }\n  //                 }\n  //             }\n  //         }        \n  //         return true\n  //     }\n\n\n}","map":{"version":3,"sources":["/home/jaybird/Coding Projects/QuantumChess/quantum-chess/src/Referee/checker.ts"],"names":["PieceType","TeamType","isLegalBishopMove","isLegalRookMove","isLegalQueenMove","isLegalKingMove","isLegalNightMove","isPawnNormalMove","Checker","constructor","boardState","oldBoardState","deepCopy","i","length","p","SuperPiece","x","y","taken","promoted","removeKing","subPieces","includes","KING","splice","removeKingsInCheck","team","enemyTeam","WHITE","BLACK","enemyPiece","j","ourPiece","dx","dy","checksLike","PAWN","NIGHT","console","log","BISHOP","ROOK","QUEEN"],"mappings":"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","sourcesContent":["/*\nThis is the file where we detrmine whether Kings are in check or checkmate.  It\nis important to remember that the isCheckMate function works by checking to see\nif there are any legal moves for a piece and returns true if there are no moves\nsometimes this can be stale mate so it must be used in conjunction with \nisMyKingInCheck to fully determine the outcome of the game.\n\n*/\n\n\nimport { PieceType, TeamType, Piece, VERTICAL_AXIS, HORIZONTAL_AXIS } from \"../constants\"\nimport { isLegalBishopMove, isLegalRookMove, isLegalQueenMove, isLegalKingMove, isLegalNightMove} from \"./pieceLogic\"\nimport SuperPiece from '../superPiece'\nimport { isPawnNormalMove } from \"./pawnLogic\"\nimport { CLICKED } from '../components/Promotion/promotion'\nimport Referee from \"./referee\"\n\nexport default class Checker {   \n    oldBoardState : Piece [] | null;\n\n    constructor (boardState: Piece [] | null){\n        this.oldBoardState = boardState\n    }\n\n    // Makes a copy of the board state so that way we can make 'hypothetical'\n    // moves and then do a 'take back'.\n    deepCopy(boardState : Piece []) {\n        if (this.oldBoardState){\n            for (let i = 0; i < this.oldBoardState.length; i ++){\n                const p = this.oldBoardState[i]\n                boardState[i] = {SuperPiece : p.SuperPiece, x : p.x, y : p.y, taken : false, promoted : false}\n            }\n        }\n    } \n    removeKing(p : Piece){\n        if (p.SuperPiece.subPieces.includes(PieceType.KING)){\n            p.SuperPiece.subPieces.splice(0, 1)\n        }\n    }\n\n    removeKingsInCheck(boardState : Piece [], team : TeamType){\n        const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE\n        for (let i = 0; i < boardState.length; i++){\n            const enemyPiece = boardState[i];\n            if (enemyPiece.SuperPiece.team === enemyTeam){\n                for (let j = 0; j < boardState.length; j++){\n                    const ourPiece = boardState[j];\n                    if (ourPiece.SuperPiece.team === team){\n                        const dx = ourPiece.x - enemyPiece.x\n                        const dy = ourPiece.y - enemyPiece.y\n                        switch (enemyPiece.SuperPiece.checksLike){\n                            case PieceType.PAWN : {\n                                if (isPawnNormalMove(enemyPiece.x, enemyPiece.y, \n                                                    ourPiece.x, ourPiece.y, \n                                                    team, boardState)){\n                                    this.removeKing(ourPiece)\n                                } break;\n                            }\n                            case PieceType.NIGHT : {\n                                console.log('OMG IM HERE')\n                                if (isLegalNightMove(enemyPiece.x, enemyPiece.y, dx, dy, boardState)){\n                                    this.removeKing(ourPiece)\n                                } break;\n                            }\n                            case PieceType.BISHOP : {\n                                if (isLegalBishopMove(enemyPiece.x, enemyPiece.y, dx, dy, boardState)){\n                                    this.removeKing(ourPiece)\n                                } break;\n                            }\n                            case PieceType.ROOK : {\n                                if (isLegalRookMove(enemyPiece.x, enemyPiece.y, dx, dy, boardState)){\n                                    this.removeKing(ourPiece)\n                                } break;\n                            }\n                            case PieceType.QUEEN : {\n                                if (isLegalQueenMove(enemyPiece.x, enemyPiece.y, dx, dy, boardState)){\n                                    this.removeKing(ourPiece)\n                                } break;\n                            }\n                            case PieceType.KING : {\n                                if (isLegalKingMove(enemyPiece.x, enemyPiece.y, dx, dy, boardState)){\n                                    this.removeKing(ourPiece)\n                                } break;\n                            }\n                        }       \n                    }\n                }\n            } \n        }\n    }\n    // // Returns true if your team has a king in check.  The increment should usually be set to 0 \n    // // but exists for checking the no castling through check rule \n    // isMyKingInCheck(team : TeamType, boardState : Piece [], increment : number) : boolean {\n    //     const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE\n    //     const myKing = boardState.find(p => p.SuperPiece.team === team && p.type === PieceType.KING) \n    //     for (let i = 0; i < boardState.length; i++){\n    //         const p = boardState[i];\n    //         if (myKing && p.SuperPiece.team === enemyTeam) {\n    //             const dx = myKing.x + increment - p.x\n    //             const dy = myKing.y - p.y\n    //             switch (p.type){\n    //                 case PieceType.PAWN : {\n    //                     if (isPawnNormalMove(p.x, p.y, myKing.x + increment, myKing.y, p.team, boardState)){\n    //                         return true;\n    //                     } break;\n    //                 }\n    //                 case PieceType.NIGHT : {\n    //                     if (isLegalNightMove(p.x, p.y, dx, dy, boardState)){\n    //                         return true;\n    //                     } break;\n    //                 }\n    //                 case PieceType.BISHOP : {\n    //                     if (isLegalBishopMove(p.x, p.y, dx, dy, boardState)){\n    //                         return true;\n    //                     } break;\n    //                 }\n    //                 case PieceType.ROOK : {\n    //                     if (isLegalRookMove(p.x, p.y, dx, dy, boardState)){\n    //                         return true;\n    //                     } break;\n    //                 }\n    //                 case PieceType.QUEEN : {\n    //                     if (isLegalQueenMove(p.x, p.y, dx, dy, boardState)){\n    //                         return true;\n    //                     } break;\n    //                 }\n    //                 case PieceType.KING : {\n    //                     if (isLegalKingMove(p.x, p.y, dx, dy, boardState)){\n    //                         return true;\n    //                     } break;\n    //                 }\n    //             }\n\n    //         }\n    //     }\n    //     return false\n    // }\n\n\n    // Returns true if the enemy team has no legal moves\n//     isCheckMate(team : TeamType, boardState : Piece []): boolean{\n//         const ref = new Referee()\n//         const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE\n//         for (let j = VERTICAL_AXIS.length - 1; j >= 0; j-- ){\n//             for (let i = 0; i < HORIZONTAL_AXIS.length; i++ ) {\n//                 for (let k = 0; k < boardState.length; k ++ ){\n//                     const p = boardState[k] \n//                     if (p.SuperPiece.team === enemyTeam)  {               \n//                         const legalMove = ref.isValidMove(p.x, p.y, i, j,  p.type, enemyTeam, boardState, enemyTeam)\n//                         this.deepCopy(boardState)\n//                         if (legalMove || !CLICKED){\n//                             return false                       \n//                         } \n//                     }\n//                 }\n            \n//             }\n//         }        \n//         return true\n\n//     }\n\n}"]},"metadata":{},"sourceType":"module"}