{"ast":null,"code":"/*\nThis class does a lot of the heavy lifting for the chess game.  Currently \nthe isValidMove also makes the move by changing the Piece [] as it checks for \nthe moves validity.  This is because once the move has been made it must use \nthe new board state to see if the move has put its own king in check which would \nactually make the move invalid.  So, if the move returns as invalid, the board \nstate must be reset. \n*/\nimport { PieceType, TeamType, AXIS } from \"../constants\";\nimport { isPawnNormalMove, isPawnStartingMove, isFriendlyPiece } from \"./pawnLogic\";\nimport { isLegalBishopMove, isLegalRookMove, isLegalQueenMove, isLegalKingMove, isLegalNightMove } from \"./pieceLogic\";\nimport Checker from './checker';\nimport { CLICKED } from '../components/Promotion/promotion';\nimport { executeMove } from \"./executeMove\";\nimport SuperPiece from \"../superPiece\";\nexport default class Referee {\n  // promote(px: number, py: number, x : number, y: number, boardState : Piece []){\n  //     const piece = boardState.find(p => p.x === px && p.y === py)\n  //     if (piece && piece.type === PieceType.PAWN && piece.team === TeamType.WHITE && y === 7){\n  //         piece.promoted = true\n  //     }   \n  //     else if (piece && piece.type === PieceType.PAWN && piece.team === TeamType.BLACK && y === 0){\n  //         piece.promoted = true\n  //     } else if (piece){\n  //         piece.promoted = false\n  //     }\n  // } \n  takePiece(x, y, team, boardState) {\n    const piece = boardState.find(p => p.x === x && p.y === y && p.SuperPiece.team !== team);\n\n    if (piece) {\n      piece.taken = true;\n    }\n  }\n\n  endMove(px, py, x, y, team, boardState, valid, startingPawnMove, enPassant) {\n    if (!isFriendlyPiece(x, y, team, boardState)) {\n      executeMove(px, py, x, y, boardState);\n      const checker = new Checker(null);\n      console.log(team); // const inCheck = checker.isMyKingInCheck(team, boardState, 0)\n      // if (inCheck){\n      //     valid.value = false\n      // }  else {\n      //     valid.value = true\n      // }      \n    }\n  }\n\n  getPossiblePieces(px, py, x, y, piece, boardState, activePlayer) {\n    const possiblePieces = [];\n\n    if (!CLICKED) {\n      return new SuperPiece([], null);\n    } // Only the active player can move\n\n\n    if (piece.team !== activePlayer) {\n      return new SuperPiece([], null);\n    } // A non-move is not a move\n\n\n    if (px === x && py === y) {\n      return new SuperPiece([], null);\n    } // A move off the board is not a move\n\n\n    if (!(AXIS.includes(px) && AXIS.includes(py) && AXIS.includes(x) && AXIS.includes(y))) {\n      return new SuperPiece([], null);\n    }\n\n    var valid = {\n      value: false\n    };\n    const dx = x - px;\n    const dy = y - py;\n    const team = piece.team ? piece.team : TeamType.WHITE;\n    piece.subPieces.forEach(p => {\n      switch (p) {\n        case PieceType.PAWN:\n          {\n            if (isPawnStartingMove(px, py, x, y, team, boardState)) {\n              possiblePieces.push(PieceType.PAWN);\n            }\n\n            if (isPawnNormalMove(px, py, x, y, team, boardState)) {\n              if (!possiblePieces.includes(PieceType.PAWN)) {\n                possiblePieces.push(PieceType.PAWN);\n              }\n            }\n\n            break;\n          }\n\n        case PieceType.NIGHT:\n          {\n            if (isLegalNightMove(px, py, dx, dy, boardState)) {\n              possiblePieces.push(PieceType.NIGHT);\n            }\n\n            break;\n          }\n\n        case PieceType.BISHOP:\n          {\n            if (isLegalBishopMove(px, py, dx, dy, boardState)) {\n              possiblePieces.push(PieceType.BISHOP);\n            }\n\n            break;\n          }\n\n        case PieceType.ROOK:\n          {\n            if (isLegalRookMove(px, py, dx, dy, boardState)) {\n              possiblePieces.push(PieceType.ROOK);\n            }\n\n            break;\n          }\n\n        case PieceType.QUEEN:\n          {\n            if (isLegalQueenMove(px, py, dx, dy, boardState)) {\n              possiblePieces.push(PieceType.QUEEN);\n            }\n\n            break;\n          }\n\n        case PieceType.KING:\n          {\n            if (isLegalKingMove(px, py, dx, dy, boardState)) {\n              possiblePieces.push(PieceType.KING);\n            }\n\n            break;\n          }\n      }\n    });\n    return valid.value;\n  }\n\n}","map":{"version":3,"sources":["/home/jaybird/Coding Projects/QuantumChess/quantum-chess/src/Referee/referee.ts"],"names":["PieceType","TeamType","AXIS","isPawnNormalMove","isPawnStartingMove","isFriendlyPiece","isLegalBishopMove","isLegalRookMove","isLegalQueenMove","isLegalKingMove","isLegalNightMove","Checker","CLICKED","executeMove","SuperPiece","Referee","takePiece","x","y","team","boardState","piece","find","p","taken","endMove","px","py","valid","startingPawnMove","enPassant","checker","console","log","getPossiblePieces","activePlayer","possiblePieces","includes","value","dx","dy","WHITE","subPieces","forEach","PAWN","push","NIGHT","BISHOP","ROOK","QUEEN","KING"],"mappings":"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","sourcesContent":["/*\nThis class does a lot of the heavy lifting for the chess game.  Currently \nthe isValidMove also makes the move by changing the Piece [] as it checks for \nthe moves validity.  This is because once the move has been made it must use \nthe new board state to see if the move has put its own king in check which would \nactually make the move invalid.  So, if the move returns as invalid, the board \nstate must be reset. \n*/\n\n\nimport { PieceType, TeamType, Piece, AXIS } from \"../constants\"\nimport { isPawnNormalMove, isPawnStartingMove, isFriendlyPiece } from \"./pawnLogic\"\nimport { isLegalBishopMove, isLegalRookMove, isLegalQueenMove, isLegalKingMove, isLegalNightMove} from \"./pieceLogic\"\nimport Checker from './checker'\nimport {CLICKED} from '../components/Promotion/promotion'\nimport { executeMove } from \"./executeMove\"\nimport SuperPiece from \"../superPiece\"\n\nexport default class Referee{\n    \n\n\n    // promote(px: number, py: number, x : number, y: number, boardState : Piece []){\n    //     const piece = boardState.find(p => p.x === px && p.y === py)\n    //     if (piece && piece.type === PieceType.PAWN && piece.team === TeamType.WHITE && y === 7){\n    //         piece.promoted = true\n    //     }   \n    //     else if (piece && piece.type === PieceType.PAWN && piece.team === TeamType.BLACK && y === 0){\n    //         piece.promoted = true\n    //     } else if (piece){\n    //         piece.promoted = false\n    //     }\n    // } \n\n    takePiece(x : number, y: number, team : TeamType, boardState : Piece []){\n        const piece = boardState.find(p => p.x === x && p.y === y && p.SuperPiece.team !== team)  \n                if (piece) {\n            piece.taken = true\n        }\n    }\n\n    endMove(px : number, py : number, x : number, y: number, team : TeamType, \n            boardState : Piece [], valid : any, startingPawnMove: boolean, enPassant: boolean){\n        if (!isFriendlyPiece(x, y, team, boardState)){\n            executeMove(px, py, x, y, boardState)\n            const checker = new Checker(null);\n            console.log(team)\n            // const inCheck = checker.isMyKingInCheck(team, boardState, 0)\n            // if (inCheck){\n            //     valid.value = false\n            // }  else {\n            //     valid.value = true\n            // }      \n        }\n    }\n    getPossiblePieces(px : number, py : number, x : number, y : number, piece : SuperPiece, \n                boardState : Piece [],  activePlayer : TeamType) : SuperPiece {\n        const possiblePieces : PieceType [] = []; \n        if (!CLICKED){\n            return new SuperPiece([], null)\n        }  \n        // Only the active player can move\n        if (piece.team !== activePlayer){\n            return new SuperPiece([], null)\n        }\n        // A non-move is not a move\n        if (px === x && py === y){\n            return new SuperPiece([], null)\n        }\n        // A move off the board is not a move\n        if (!(AXIS.includes(px) &&  AXIS.includes(py) &&  AXIS.includes(x) && AXIS.includes(y))){\n            return new SuperPiece([], null)\n        }\n        var valid = { value: false }\n        const dx = x - px\n        const dy = y - py\n        const team = piece.team ? piece.team : TeamType.WHITE\n        piece.subPieces.forEach(p =>  {\n            switch(p){\n                case PieceType.PAWN : {\n                    if (isPawnStartingMove(px, py, x, y, team, boardState)){\n                        possiblePieces.push(PieceType.PAWN)\n                    }\n                    if (isPawnNormalMove(px, py, x, y, team, boardState)){\n                        if (!possiblePieces.includes(PieceType.PAWN)){\n                            possiblePieces.push(PieceType.PAWN)\n                        }\n                    }\n                    break;\n                }\n                case PieceType.NIGHT : {\n                    if (isLegalNightMove(px, py, dx, dy, boardState)){\n                        possiblePieces.push(PieceType.NIGHT)\n                    }\n                    break;\n                }\n                case PieceType.BISHOP : {\n                    if (isLegalBishopMove(px, py, dx, dy, boardState)){\n                        possiblePieces.push(PieceType.BISHOP)\n                    }\n                    break;\n                }\n                case PieceType.ROOK : {\n                    if (isLegalRookMove(px, py, dx, dy, boardState)){\n                        possiblePieces.push(PieceType.ROOK)\n                    }\n                    break;\n                }\n                case PieceType.QUEEN : {\n                    if (isLegalQueenMove(px, py, dx, dy, boardState)){\n                        possiblePieces.push(PieceType.QUEEN)\n                    }\n                    break;\n                }\n                case PieceType.KING : {\n                    if (isLegalKingMove(px, py, dx, dy, boardState)){\n                        possiblePieces.push(PieceType.KING)\n                    }\n                    break;\n                }\n\n            }\n        })\n    return valid.value\n    }\n}"]},"metadata":{},"sourceType":"module"}