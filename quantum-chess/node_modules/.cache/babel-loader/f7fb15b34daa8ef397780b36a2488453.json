{"ast":null,"code":"import { PieceType, TeamType } from \"../components/chessboard/chessboard\";\nexport default class Referee {\n  pawnIsBlockaded(x, y, boardState) {\n    const piece = boardState.find(p => p.x === x && p.y === y);\n    const occupied = piece ? true : false;\n    return occupied;\n  }\n\n  isOpposingPiece(x, y, team, boardState) {\n    const piece = boardState.find(p => p.x === x && p.y === y);\n    console.log(piece === null || piece === void 0 ? void 0 : piece.x);\n    const occupied = piece && piece.team !== team ? true : false;\n    console.log(\"we are checking attacking square\");\n    console.log(piece === null || piece === void 0 ? void 0 : piece.team, team);\n    console.log(occupied);\n    return occupied;\n  }\n\n  isValidMove(px, py, x, y, type, team, boardState) {\n    console.log(\"Ref checking the move .... \");\n\n    if (type === PieceType.PAWN) {\n      const startingRow = team === TeamType.WHITE ? 1 : 6;\n      const increment = team === TeamType.WHITE ? 1 : -1; // Moving Logic\n\n      if (py === startingRow && px === x && py === y - 2 * increment) {\n        if (!this.pawnIsBlockaded(x, y, boardState) && !this.pawnIsBlockaded(x, y - increment, boardState)) {\n          return true;\n        }\n      }\n\n      if (py === y - increment && px === x) {\n        if (!this.pawnIsBlockaded(x, y, boardState)) {\n          return true;\n        }\n      } // ATTACK LOGIC\n\n\n      if ((x === px + 1 || x === px - 1) && py === y - increment && this.isOpposingPiece(x, y - increment, team, boardState)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}","map":{"version":3,"sources":["/home/jaybird/Coding Projects/Chess4/chess/src/referee/Referee.ts"],"names":["PieceType","TeamType","Referee","pawnIsBlockaded","x","y","boardState","piece","find","p","occupied","isOpposingPiece","team","console","log","isValidMove","px","py","type","PAWN","startingRow","WHITE","increment"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,QAApB,QAA2C,qCAA3C;AAEA,eAAe,MAAMC,OAAN,CAAa;AACxBC,EAAAA,eAAe,CAACC,CAAD,EAAaC,CAAb,EAAwBC,UAAxB,EAAwD;AACnE,UAAMC,KAAK,GAAGD,UAAU,CAACE,IAAX,CAAgBC,CAAC,IAAIA,CAAC,CAACL,CAAF,KAAQA,CAAR,IAAaK,CAAC,CAACJ,CAAF,KAAQA,CAA1C,CAAd;AACA,UAAMK,QAAQ,GAAIH,KAAK,GAAG,IAAH,GAAU,KAAjC;AACA,WAAOG,QAAP;AACH;;AAEDC,EAAAA,eAAe,CAACP,CAAD,EAAaC,CAAb,EAAwBO,IAAxB,EAAyCN,UAAzC,EAAyE;AACpF,UAAMC,KAAK,GAAGD,UAAU,CAACE,IAAX,CAAgBC,CAAC,IAAIA,CAAC,CAACL,CAAF,KAAQA,CAAR,IAAaK,CAAC,CAACJ,CAAF,KAAQA,CAA1C,CAAd;AACAQ,IAAAA,OAAO,CAACC,GAAR,CAAYP,KAAZ,aAAYA,KAAZ,uBAAYA,KAAK,CAAEH,CAAnB;AACA,UAAMM,QAAQ,GAAKH,KAAK,IAAIA,KAAK,CAACK,IAAN,KAAeA,IAAzB,GAAiC,IAAjC,GAAwC,KAA1D;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAY,kCAAZ;AACAD,IAAAA,OAAO,CAACC,GAAR,CAAYP,KAAZ,aAAYA,KAAZ,uBAAYA,KAAK,CAAEK,IAAnB,EAAyBA,IAAzB;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYJ,QAAZ;AACA,WAAOA,QAAP;AACH;;AACDK,EAAAA,WAAW,CAACC,EAAD,EAAcC,EAAd,EAA2Bb,CAA3B,EAAuCC,CAAvC,EAAmDa,IAAnD,EAAqEN,IAArE,EAAsFN,UAAtF,EAA4G;AACnHO,IAAAA,OAAO,CAACC,GAAR,CAAY,6BAAZ;;AAEA,QAAII,IAAI,KAAKlB,SAAS,CAACmB,IAAvB,EAA4B;AACxB,YAAMC,WAAW,GAAGR,IAAI,KAAKX,QAAQ,CAACoB,KAAlB,GAA0B,CAA1B,GAA8B,CAAlD;AACA,YAAMC,SAAS,GAAGV,IAAI,KAAKX,QAAQ,CAACoB,KAAlB,GAA0B,CAA1B,GAA8B,CAAE,CAAlD,CAFwB,CAGxB;;AACA,UAAKJ,EAAE,KAAKG,WAAP,IAAsBJ,EAAE,KAAKZ,CAA9B,IAAqCa,EAAE,KAAKZ,CAAC,GAAG,IAAIiB,SAAxD,EAAmE;AAC/D,YAAI,CAAC,KAAKnB,eAAL,CAAqBC,CAArB,EAAwBC,CAAxB,EAA2BC,UAA3B,CAAD,IAA2C,CAAC,KAAKH,eAAL,CAAqBC,CAArB,EAAwBC,CAAC,GAAGiB,SAA5B,EAAuChB,UAAvC,CAAhD,EAAmG;AAC/F,iBAAO,IAAP;AACH;AACJ;;AACD,UAAIW,EAAE,KAAKZ,CAAC,GAAGiB,SAAX,IAAwBN,EAAE,KAAKZ,CAAnC,EAAqC;AACjC,YAAI,CAAC,KAAKD,eAAL,CAAqBC,CAArB,EAAwBC,CAAxB,EAA2BC,UAA3B,CAAL,EAA4C;AACxC,iBAAO,IAAP;AACH;AACJ,OAbuB,CAcxB;;;AACA,UAAI,CAACF,CAAC,KAAKY,EAAE,GAAG,CAAX,IAAgBZ,CAAC,KAAKY,EAAE,GAAE,CAA3B,KAAkCC,EAAE,KAAKZ,CAAC,GAAGiB,SAA7C,IAA2D,KAAKX,eAAL,CAAqBP,CAArB,EAAwBC,CAAC,GAAGiB,SAA5B,EAAuCV,IAAvC,EAA6CN,UAA7C,CAA/D,EAAyH;AACrH,eAAO,IAAP;AACH;AACJ;;AACD,WAAO,KAAP;AACH;;AAvCuB","sourcesContent":["import { PieceType, TeamType, Piece } from \"../components/chessboard/chessboard\"\n\nexport default class Referee{\n    pawnIsBlockaded(x : number, y: number, boardState : Piece []): boolean {\n        const piece = boardState.find(p => p.x === x && p.y === y) \n        const occupied =  piece ? true : false\n        return occupied\n    }\n    \n    isOpposingPiece(x : number, y: number, team : TeamType, boardState : Piece []): boolean {\n        const piece = boardState.find(p => p.x === x && p.y === y) \n        console.log(piece?.x)\n        const occupied =  (piece && piece.team !== team) ? true : false\n        console.log(\"we are checking attacking square\")\n        console.log(piece?.team, team)\n        console.log(occupied)\n        return occupied\n    }\n    isValidMove(px : number, py : number, x : number, y : number, type : PieceType, team : TeamType, boardState : Piece []){\n        console.log(\"Ref checking the move .... \")\n\n        if (type === PieceType.PAWN){\n            const startingRow = team === TeamType.WHITE ? 1 : 6\n            const increment = team === TeamType.WHITE ? 1 : - 1\n            // Moving Logic\n            if ((py === startingRow && px === x) && (py === y - 2 * increment)){\n                if (!this.pawnIsBlockaded(x, y, boardState) && !this.pawnIsBlockaded(x, y - increment, boardState)){\n                    return true\n                }\n            } \n            if (py === y - increment && px === x){\n                if (!this.pawnIsBlockaded(x, y, boardState)){\n                    return true;\n                }\n            } \n            // ATTACK LOGIC\n            if ((x === px + 1 || x === px -1) && (py === y - increment) && this.isOpposingPiece(x, y - increment, team, boardState)) {\n                return true\n            }\n        }\n        return false\n    }\n}"]},"metadata":{},"sourceType":"module"}