{"ast":null,"code":"/* \nThis file handles the surprisingly complicated PAWN movement. This includes \nthe PAWN's special starting move, special diagonal taking move, ability to take \nen passant, ability to be taken en passant, and promoting upon reaching the \nother side of the board. Also contains the ever useful function isFriendlyPiece().\nThis Section of code could be cleaned up a little bit but right now everything is \nworking perfectly so if it ain't broke don't fix it.\n*/\nimport { TeamType } from '../constants';\nimport SuperPiece from '../superPiece';\nimport { PROMOTED_PIECE } from '../components/Promotion/promotion';\nimport { change_piece_count } from './stateReducer'; // Checks to see if a piece is in the way, this is different from other pieces\n// since normally if an enemy piece is on the square you are moving to \n// the piece is captured, a pawn however, is blockaded.\n\nfunction pawnIsBlockaded(x, y, boardState) {\n  const piece = boardState.find(p => p.x === x && p.y === y);\n  const occupied = piece ? true : false;\n  return occupied;\n} // Returns true if the piece on square x, y belongs to the team\n\n\nexport function isFriendlyPiece(x, y, team, boardState) {\n  const piece = boardState.find(p => p.x === x && p.y === y);\n  const occupied = piece && piece.SuperPiece.team === team ? true : false;\n  return occupied;\n} // Returns true if a pawn is moving 2 squares forward\n\nexport function isPawnStartingMove(px, py, x, y, team, boardState) {\n  const startingRow = team === TeamType.WHITE ? 1 : 6;\n  const increment = team === TeamType.WHITE ? 1 : -1;\n\n  if ((py === startingRow || py === startingRow - increment) && px === x && py === y - 2 * increment) {\n    if (!pawnIsBlockaded(x, y, boardState) && !pawnIsBlockaded(x, y - increment, boardState)) {\n      return true;\n    }\n  }\n\n  return false;\n} // Returns true if the the pawn can move from px, py to x, y this covers the case of capturing \n// diagonally.\n\nexport function isPawnNormalMove(px, py, x, y, team, boardState) {\n  const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE;\n  const increment = team === TeamType.WHITE ? 1 : -1;\n\n  if (py === y - increment && px === x) {\n    if (!pawnIsBlockaded(x, y, boardState)) {\n      return true;\n    }\n  }\n\n  if ((x === px + 1 || x === px - 1) && py === y - increment && isFriendlyPiece(x, y, enemyTeam, boardState)) {\n    return true;\n  }\n\n  return false;\n} // Promotes a pawn to a QUEEN, ROOK, BISHOP, or NIGHT\n\nexport function promotePieces(boardState) {\n  const promotedPiece = boardState.find(p => p.promoted === true);\n\n  if (promotedPiece) {\n    const id = boardState.indexOf(promotedPiece);\n    boardState[id] = {\n      SuperPiece: new SuperPiece([PROMOTED_PIECE], promotedPiece.SuperPiece.team),\n      x: promotedPiece.x,\n      y: promotedPiece.y,\n      taken: false,\n      promoted: false\n    };\n    change_piece_count(PROMOTED_PIECE, promotedPiece.SuperPiece.team);\n  }\n}","map":{"version":3,"sources":["/home/jaybird/Coding Projects/QuantumChess/quantum-chess/src/Referee/pawnLogic.ts"],"names":["TeamType","SuperPiece","PROMOTED_PIECE","change_piece_count","pawnIsBlockaded","x","y","boardState","piece","find","p","occupied","isFriendlyPiece","team","isPawnStartingMove","px","py","startingRow","WHITE","increment","isPawnNormalMove","enemyTeam","BLACK","promotePieces","promotedPiece","promoted","id","indexOf","taken"],"mappings":"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","sourcesContent":["/* \nThis file handles the surprisingly complicated PAWN movement. This includes \nthe PAWN's special starting move, special diagonal taking move, ability to take \nen passant, ability to be taken en passant, and promoting upon reaching the \nother side of the board. Also contains the ever useful function isFriendlyPiece().\nThis Section of code could be cleaned up a little bit but right now everything is \nworking perfectly so if it ain't broke don't fix it.\n*/\n\n\nimport { Piece, PieceType, TeamType } from '../constants'\nimport SuperPiece from '../superPiece'\nimport {PROMOTED_PIECE} from '../components/Promotion/promotion'\nimport {change_piece_count} from './stateReducer'\n\n\n// Checks to see if a piece is in the way, this is different from other pieces\n// since normally if an enemy piece is on the square you are moving to \n// the piece is captured, a pawn however, is blockaded.\n\nfunction pawnIsBlockaded(x : number, y: number, boardState : Piece []): boolean {\n    const piece = boardState.find(p => p.x === x && p.y === y) \n    const occupied =  piece ? true : false\n    return occupied\n}\n\n// Returns true if the piece on square x, y belongs to the team\n\nexport function isFriendlyPiece(x : number, y: number, team : TeamType, boardState : Piece []): boolean {\n    const piece = boardState.find(p => p.x === x && p.y === y)\n    const occupied =  piece && piece.SuperPiece.team === team ? true : false\n    return occupied\n}\n// Returns true if a pawn is moving 2 squares forward\n\nexport function isPawnStartingMove(px : number, py : number, x : number, y : number, \n                                    team : TeamType, boardState : Piece []):boolean{\n    const startingRow = team === TeamType.WHITE ? 1 : 6\n    const increment = team === TeamType.WHITE ? 1 : - 1\n    if (((py === startingRow || py === startingRow - increment) && px === x) && (py === y - 2 * increment)){\n        if (!pawnIsBlockaded(x, y, boardState) && !pawnIsBlockaded(x, y - increment, boardState)){\n            return true\n        }\n    } return false\n}\n// Returns true if the the pawn can move from px, py to x, y this covers the case of capturing \n// diagonally.\n\nexport function isPawnNormalMove(px : number, py : number, x : number, y : number, \n                                team : TeamType, boardState : Piece []): boolean{\n    const enemyTeam = team === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE\n    const increment = team === TeamType.WHITE ? 1 : - 1\n    if (py === y - increment && px === x){\n        if (!pawnIsBlockaded(x, y, boardState)){\n            return true;\n        } \n    }\n    if ((x === px + 1 || x === px -1) && (py === y - increment) && isFriendlyPiece(x, y, enemyTeam, boardState)) {\n        return true\n    } \n    return false \n} \n\n// Promotes a pawn to a QUEEN, ROOK, BISHOP, or NIGHT\n\nexport function promotePieces(boardState : Piece []){\n    const promotedPiece = boardState.find(p => p.promoted === true)\n    if (promotedPiece){\n        const id = boardState.indexOf(promotedPiece)\n        boardState[id] = {SuperPiece : new SuperPiece([PROMOTED_PIECE], promotedPiece.SuperPiece.team), \n                        x : promotedPiece.x,  y: promotedPiece.y, taken : false, promoted : false}\n        change_piece_count(PROMOTED_PIECE, promotedPiece.SuperPiece.team)\n    }\n}"]},"metadata":{},"sourceType":"module"}