{"ast":null,"code":"var _jsxFileName = \"/home/jaybird/Coding Projects/QuantumChess/quantum-chess/src/components/Chessboard/chessboard.tsx\",\n    _s = $RefreshSig$();\n\n/*\nThis is the chess board react based function.  It is the only element in our App.tsx and\nit is responsible for keeping the Piece [] in sync with the displayed tiles of the \nchess board.  The boards state updates via React hooks which are all declared at \nthe top of the function. \n*/\nimport React, { useRef, useState } from 'react';\nimport Tile from '../Tile/tile';\nimport './chessboard.css';\nimport Referee from '../../Referee/referee';\nimport { AXIS, GRID_SIZE, TeamType, initializeBoardState } from '../../constants';\nimport Checker from '../../Referee/checker';\nimport { CLICKED1 } from '../Promotion/promotion';\nimport { promotePieces } from '../../Referee/pawnLogic';\nimport { executeMove, setTAKEN } from '../../Referee/executeMove';\nimport { fullReduction } from '../../Referee/stateReducer';\nimport { TAKEN_PIECE } from '../../Referee/executeMove';\nimport TakePiece, { CLICKED2, resetTakenPieces } from '../TakePiece/TakePiece';\nimport SuperPiece from '../../superPiece';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function Chessboard() {\n  _s();\n\n  const [activePiece, setActivePiece] = useState(null);\n  const [gridX, setGridX] = useState(0);\n  const [gridY, setGridY] = useState(0);\n  const [pieces, setPieces] = useState(initializeBoardState());\n  const [activePlayer, setActivePlayer] = useState(TeamType.WHITE);\n  const [winner, setWinner] = useState('');\n  const [[checkMate, message], setCheckMate] = useState([false, '']);\n  const chessboardRef = useRef(null);\n  const referee = new Referee();\n  let board = []; // Returns the board state to the original board state\n\n  function newGame() {\n    setPieces(initializeBoardState());\n    setActivePlayer(TeamType.WHITE);\n    setCheckMate([false, ' ']);\n    setTAKEN(null);\n    resetTakenPieces();\n  }\n\n  function add_piece_to_bin() {\n    if (CLICKED2) {\n      fullReduction(pieces);\n      pieces.forEach(p => {\n        p.SuperPiece.setURL();\n      });\n      setPieces([...pieces]);\n    }\n  } // Used To make a copy of the piece array.  This is useful to pass while \n  // cheking for check mate so the actual board state does not get changed \n  // in the process\n\n\n  function deepCopy() {\n    const oldBoardState = [];\n    pieces.forEach(p => oldBoardState.push({\n      SuperPiece: new SuperPiece([...p.SuperPiece.subPieces], p.SuperPiece.team),\n      x: p.x,\n      y: p.y,\n      promoted: p.promoted\n    }));\n    return oldBoardState;\n  } // Switches the game state from WHITE to BLACK and vice versa\n\n\n  function switchPlayer() {\n    const nextPlayer = activePlayer === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE;\n    setActivePlayer(nextPlayer);\n  } // Returns the active piece to its original location.\n\n\n  function revert(boardState) {\n    if (activePiece) {\n      activePiece.style.position = 'relative';\n      activePiece.style.removeProperty('left');\n      activePiece.style.removeProperty('top');\n      setPieces(boardState);\n    }\n  } // Tries to look for 'chess-piece' in the HTML of the clicked area \n  // to see if a player is trying to grab a piece\n\n\n  function grabPiece(e) {\n    const chessboard = chessboardRef.current;\n    const element = e.target;\n\n    if (element.classList.contains('chess-piece') && chessboard) {\n      setGridX(Math.floor((e.clientX - chessboard.offsetLeft) / GRID_SIZE));\n      setGridY(Math.abs(Math.ceil((e.clientY - chessboard.offsetTop - 8 * GRID_SIZE) / GRID_SIZE)));\n      const x = e.clientX - chessboard.offsetLeft - GRID_SIZE / 2;\n      const y = e.clientY - chessboard.offsetTop - GRID_SIZE / 2;\n      element.style.position = 'absolute';\n      element.style.left = `${x}px`;\n      element.style.top = `${y}px`;\n      setActivePiece(element);\n    }\n  } // Places the center of the active piece beneath the cursor\n\n\n  function movePiece(e) {\n    const chessboard = chessboardRef.current;\n\n    if (activePiece && chessboard) {\n      const x = e.clientX - chessboard.offsetLeft - GRID_SIZE / 2;\n      const y = e.clientY - chessboard.offsetTop - GRID_SIZE / 2;\n      activePiece.style.position = 'absolute';\n      activePiece.style.left = `${x}px`;\n      activePiece.style.top = `${y}px`;\n    }\n  }\n\n  function dropPiece(e) {\n    const chessboard = chessboardRef.current;\n\n    if (activePiece && chessboard) {\n      if (CLICKED1) {\n        promotePieces(pieces);\n      }\n\n      const x = Math.floor((e.clientX - chessboard.offsetLeft) / GRID_SIZE);\n      const y = Math.abs(Math.ceil((e.clientY - chessboard.offsetTop - 8 * GRID_SIZE) / GRID_SIZE));\n      const currentPiece = pieces.find(p => p.x === gridX && p.y === gridY);\n\n      if (currentPiece) {\n        const oldBoardState = deepCopy();\n        const possiblePieces = referee.getPossiblePieces(gridX, gridY, x, y, currentPiece.SuperPiece, pieces, activePlayer);\n\n        if (possiblePieces.length > 0) {\n          const checker = new Checker(null);\n          executeMove(gridX, gridY, x, y, possiblePieces, activePlayer, pieces);\n          pieces.forEach(p => {\n            p.SuperPiece.setChecksLike();\n          });\n          checker.removeKingsInCheck(pieces, activePlayer);\n          fullReduction(pieces);\n          const inCheck = checker.isMyKingInCheck(activePlayer, pieces);\n\n          if (!inCheck) {\n            pieces.forEach(p => {\n              p.SuperPiece.setURL();\n            });\n            setPieces(pieces);\n            switchPlayer();\n          } else {\n            revert(oldBoardState);\n            pieces.forEach(p => {\n              p.SuperPiece.setURL();\n            });\n          }\n        } else {\n          revert(oldBoardState);\n          pieces.forEach(p => {\n            p.SuperPiece.setURL();\n          });\n        }\n\n        const boardState = deepCopy();\n        const boardState2 = deepCopy();\n        const checker = new Checker(boardState2);\n        const oppponent = activePlayer === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE;\n        const checkMate = checker.isCheckMate(activePlayer, boardState);\n\n        if (checkMate) {\n          if (checker.isMyKingInCheck(oppponent, boardState)) {\n            const winner = activePlayer === TeamType.WHITE ? 'White Wins' : 'Black Wins';\n            setWinner(winner);\n            setCheckMate([true, 'Check Mate']);\n          } else {\n            setWinner('Players Draw');\n            setCheckMate([true, 'Stale Mate']);\n          }\n        }\n      }\n    } else {\n      revert(pieces);\n    }\n\n    setActivePiece(null);\n  } // This code places 64 squares on the chessboard and for each square will look to see if their is \n  // a piece to place the image on. The HTML for the tiles is in the Tile subdirectory\n\n\n  for (let j = AXIS.length - 1; j >= 0; j--) {\n    for (let i = 0; i < AXIS.length; i++) {\n      const number = i + j;\n      const piece = pieces.find(p => p.x === i && p.y === j);\n      let image = piece ? piece.SuperPiece.img_url : undefined;\n      const promotedPiece = pieces.find(p => p.promoted === true);\n      const team = promotedPiece && promotedPiece.y === 7 ? TeamType.WHITE : TeamType.BLACK;\n\n      if (promotedPiece && promotedPiece.x === i && promotedPiece.y === j) {\n        board.push( /*#__PURE__*/_jsxDEV(Tile, {\n          image: image,\n          number: number,\n          team: team,\n          isPromotion: true\n        }, `${i}, ${j}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 172,\n          columnNumber: 28\n        }, this));\n      } else {\n        board.push( /*#__PURE__*/_jsxDEV(Tile, {\n          image: image,\n          number: number,\n          team: team,\n          isPromotion: false\n        }, `${i}, ${j}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 174,\n          columnNumber: 28\n        }, this));\n      }\n    }\n  } // Continues the game if it is not over otherwise displays the game result and prompts the user to play again\n\n\n  if (!checkMate) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"container\",\n      onClick: add_piece_to_bin,\n      children: [/*#__PURE__*/_jsxDEV(TakePiece, {\n        piece: TAKEN_PIECE\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 182,\n        columnNumber: 5\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        ref: chessboardRef,\n        onMouseUp: e => dropPiece(e),\n        onMouseMove: e => movePiece(e),\n        onMouseDown: e => grabPiece(e),\n        className: \"chessboard\",\n        children: board\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 182,\n        columnNumber: 39\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 181,\n      columnNumber: 12\n    }, this);\n  } else {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        ref: chessboardRef,\n        className: \"chessboard grayed-out\",\n        children: board\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 191,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"check\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"mate\",\n          children: [\" \", message, \" \", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 195,\n            columnNumber: 41\n          }, this), \" \", winner, \" \"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 195,\n          columnNumber: 5\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 194,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"newgame\",\n        onClick: newGame,\n        children: \" Play Again \"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 197,\n        columnNumber: 5\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 191,\n      columnNumber: 12\n    }, this);\n  }\n}\n\n_s(Chessboard, \"1BTW72ZQ+ODjnAybwXOI7vYabGQ=\");\n\n_c = Chessboard;\n\nvar _c;\n\n$RefreshReg$(_c, \"Chessboard\");","map":{"version":3,"sources":["/home/jaybird/Coding Projects/QuantumChess/quantum-chess/src/components/Chessboard/chessboard.tsx"],"names":["React","useRef","useState","Tile","Referee","AXIS","GRID_SIZE","TeamType","initializeBoardState","Checker","CLICKED1","promotePieces","executeMove","setTAKEN","fullReduction","TAKEN_PIECE","TakePiece","CLICKED2","resetTakenPieces","SuperPiece","Chessboard","activePiece","setActivePiece","gridX","setGridX","gridY","setGridY","pieces","setPieces","activePlayer","setActivePlayer","WHITE","winner","setWinner","checkMate","message","setCheckMate","chessboardRef","referee","board","newGame","add_piece_to_bin","forEach","p","setURL","deepCopy","oldBoardState","push","subPieces","team","x","y","promoted","switchPlayer","nextPlayer","BLACK","revert","boardState","style","position","removeProperty","grabPiece","e","chessboard","current","element","target","classList","contains","Math","floor","clientX","offsetLeft","abs","ceil","clientY","offsetTop","left","top","movePiece","dropPiece","currentPiece","find","possiblePieces","getPossiblePieces","length","checker","setChecksLike","removeKingsInCheck","inCheck","isMyKingInCheck","boardState2","oppponent","isCheckMate","j","i","number","piece","image","img_url","undefined","promotedPiece"],"mappings":"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","sourcesContent":["\n/*\nThis is the chess board react based function.  It is the only element in our App.tsx and\nit is responsible for keeping the Piece [] in sync with the displayed tiles of the \nchess board.  The boards state updates via React hooks which are all declared at \nthe top of the function. \n*/\n\nimport React, { useRef, useState, } from 'react';\nimport Tile from '../Tile/tile';\nimport './chessboard.css';\nimport Referee from '../../Referee/referee'\nimport {AXIS, GRID_SIZE, Piece, TeamType, initializeBoardState} from '../../constants'\nimport Checker from '../../Referee/checker'\nimport {CLICKED1} from '../Promotion/promotion';\nimport {promotePieces} from '../../Referee/pawnLogic'\nimport { executeMove, setTAKEN } from '../../Referee/executeMove';\nimport  {fullReduction}  from '../../Referee/stateReducer';\nimport {TAKEN_PIECE} from '../../Referee/executeMove'\nimport TakePiece, { CLICKED2, resetTakenPieces} from '../TakePiece/TakePiece';\nimport SuperPiece from '../../superPiece';\n\n\nexport default function Chessboard(){\n    const [activePiece, setActivePiece] = useState<HTMLElement | null>(null) \n    const [gridX, setGridX] = useState(0);\n    const [gridY, setGridY] = useState(0);\n    const [pieces, setPieces]  = useState<Piece[]>(initializeBoardState());\n    const [activePlayer, setActivePlayer] = useState<TeamType>(TeamType.WHITE);\n    const [winner, setWinner]  = useState('');\n    const [[checkMate, message], setCheckMate] = useState([false, '']);\n    const chessboardRef = useRef<HTMLDivElement>(null);\n    const referee = new Referee();\n    let board = [];\n    \n    // Returns the board state to the original board state\n    function newGame(){\n        setPieces(initializeBoardState())\n        setActivePlayer(TeamType.WHITE)\n        setCheckMate([false, ' '])\n        setTAKEN(null)\n        resetTakenPieces()\n    }\n    function add_piece_to_bin(){\n        if (CLICKED2){\n            fullReduction(pieces)\n            pieces.forEach(p => {p.SuperPiece.setURL()})\n            setPieces([...pieces])\n        }\n    }\n    // Used To make a copy of the piece array.  This is useful to pass while \n    // cheking for check mate so the actual board state does not get changed \n    // in the process\n    function deepCopy() {\n        const oldBoardState : Piece[] = [];\n        pieces.forEach(p => oldBoardState.push({SuperPiece : new SuperPiece([...p.SuperPiece.subPieces], p.SuperPiece.team), \n                                                x : p.x,  y : p.y, promoted: p.promoted}))\n        return oldBoardState\n    }\n\n    // Switches the game state from WHITE to BLACK and vice versa\n    function switchPlayer(){\n        const nextPlayer = activePlayer === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE\n        setActivePlayer(nextPlayer) \n    }\n\n    // Returns the active piece to its original location.\n    function revert(boardState : Piece []){\n        if (activePiece){\n            activePiece.style.position = 'relative';\n            activePiece.style.removeProperty('left');\n            activePiece.style.removeProperty('top');\n            setPieces(boardState)\n        }\n        \n    }\n\n    // Tries to look for 'chess-piece' in the HTML of the clicked area \n    // to see if a player is trying to grab a piece\n    function grabPiece(e: React.MouseEvent){\n        const chessboard = chessboardRef.current\n        const element = e.target as HTMLElement\n        if (element.classList.contains('chess-piece') && chessboard){\n            setGridX(Math.floor((e.clientX - chessboard.offsetLeft)/GRID_SIZE));\n            setGridY(Math.abs(Math.ceil((e.clientY - chessboard.offsetTop - 8 * GRID_SIZE)/GRID_SIZE)));\n            const x = e.clientX -  chessboard.offsetLeft - GRID_SIZE/2;\n            const y = e.clientY - chessboard.offsetTop - GRID_SIZE/2;\n            element.style.position = 'absolute'; \n            element.style.left = `${x}px`;\n            element.style.top = `${y}px`;\n            setActivePiece(element)    \n        }\n    \n    }\n    // Places the center of the active piece beneath the cursor\n    function movePiece(e: React.MouseEvent){\n        const chessboard = chessboardRef.current\n        if (activePiece && chessboard){\n            const x = e.clientX -  chessboard.offsetLeft - GRID_SIZE/2;\n            const y = e.clientY - chessboard.offsetTop - GRID_SIZE/2;\n            activePiece.style.position = 'absolute'; \n            activePiece.style.left = `${x}px`;\n            activePiece.style.top = `${y}px`;\n        }\n    }\n\n    function dropPiece(e: React.MouseEvent){\n        const chessboard = chessboardRef.current;\n        if (activePiece && chessboard){\n            if (CLICKED1){\n                promotePieces(pieces)\n            }  \n            const x = Math.floor((e.clientX - chessboard.offsetLeft)/GRID_SIZE);\n            const y = Math.abs(Math.ceil((e.clientY - chessboard.offsetTop - 8 * GRID_SIZE)/GRID_SIZE))\n            const currentPiece = pieces.find(p => p.x === gridX && p.y === gridY)\n            if (currentPiece){\n                const oldBoardState = deepCopy()\n                const possiblePieces = referee.getPossiblePieces(gridX, gridY, x, y, currentPiece.SuperPiece, pieces, activePlayer);                               \n                if (possiblePieces.length > 0){  \n                    const checker = new Checker(null);\n                    executeMove(gridX, gridY, x, y, possiblePieces, activePlayer, pieces)\n                    pieces.forEach(p => {p.SuperPiece.setChecksLike()})\n                    checker.removeKingsInCheck(pieces, activePlayer)\n                    fullReduction(pieces)\n                    const inCheck = checker.isMyKingInCheck(activePlayer, pieces)\n                    if (!inCheck){\n                        pieces.forEach(p => {p.SuperPiece.setURL()})\n                        setPieces(pieces)\n                        switchPlayer()\n                    } else{\n                        revert(oldBoardState) \n                        pieces.forEach(p => {p.SuperPiece.setURL()})\n                    }\n                } else {\n                    revert(oldBoardState)\n                    pieces.forEach(p => {p.SuperPiece.setURL()})\n            }\n            const boardState = deepCopy()\n            const boardState2 = deepCopy()\n            const checker = new Checker(boardState2);\n            const oppponent = activePlayer === TeamType.WHITE ? TeamType.BLACK : TeamType.WHITE\n            const checkMate = checker.isCheckMate(activePlayer, boardState)\n            if (checkMate){\n                if(checker.isMyKingInCheck(oppponent, boardState)){\n                    const winner = activePlayer === TeamType.WHITE ? 'White Wins' : 'Black Wins'\n                    setWinner(winner)\n                    setCheckMate([true, 'Check Mate'])\n                } else {\n                    setWinner('Players Draw')\n                    setCheckMate([true, 'Stale Mate'])\n                }\n\n            }\n        }\n    } else {\n            revert(pieces)\n    }\n    setActivePiece(null);\n    }\n\n\n    // This code places 64 squares on the chessboard and for each square will look to see if their is \n    // a piece to place the image on. The HTML for the tiles is in the Tile subdirectory\n    for (let j = AXIS.length - 1; j >= 0; j-- ){\n        for (let i = 0; i < AXIS.length; i++ ) {\n            const number = i + j;\n            const piece = pieces.find(p => p.x === i && p.y === j) \n            let image = piece ? piece.SuperPiece.img_url : undefined\n            const promotedPiece = pieces.find(p => p.promoted === true)\n            const team = promotedPiece && promotedPiece.y === 7 ? TeamType.WHITE : TeamType.BLACK \n            if (promotedPiece && promotedPiece.x === i && promotedPiece.y === j){\n                board.push(<Tile key = {`${i}, ${j}`} image = {image} number = {number} team = {team} isPromotion = {true}/>);\n            } else {\n                board.push(<Tile key = {`${i}, ${j}`} image = {image} number = {number} team = {team} isPromotion = {false}/>);\n            }\n        }\n    }\n\n    // Continues the game if it is not over otherwise displays the game result and prompts the user to play again\n    if (!checkMate){\n    return <div className = 'container' onClick = {add_piece_to_bin}>\n    <TakePiece piece = {TAKEN_PIECE}/><div\n    ref = {chessboardRef} \n    onMouseUp = {e => dropPiece(e)} \n    onMouseMove = {e => movePiece(e)} \n    onMouseDown = {e => grabPiece(e)} \n    className = 'chessboard'>{board}\n    </div></div>;\n    } \n    else {\n    return <div><div \n    ref = {chessboardRef} \n    className = 'chessboard grayed-out' >{board}\n    </div><div className = 'check'>\n    <div className = 'mate' > {message} <br></br> {winner} </div>\n    </div>\n    <button className = 'newgame' onClick = {newGame}> Play Again </button>\n    </div>;\n    }\n}"]},"metadata":{},"sourceType":"module"}