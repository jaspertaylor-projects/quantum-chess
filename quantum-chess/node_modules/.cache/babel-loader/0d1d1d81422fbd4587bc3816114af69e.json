{"ast":null,"code":"/*\nThis class does a lot of the heavy lifting for the chess game.  Currently \nthe isValidMove also makes the move by changing the Piece [] as it checks for \nthe moves validity.  This is because once the move has been made it must use \nthe new board state to see if the move has put its own king in check which would \nactually make the move invalid.  So, if the move returns as invalid, the board \nstate must be reset. \n*/\nimport { PieceType, TeamType, AXIS } from \"../constants\";\nimport { isPawnNormalMove, isPawnStartingMove, isFriendlyPiece } from \"./pawnLogic\";\nimport { isLegalBishopMove, isLegalRookMove, isLegalQueenMove, isLegalKingMove, isLegalNightMove } from \"./pieceLogic\";\nimport Checker from './checker';\nimport { CLICKED } from '../components/Promotion/promotion';\nimport { executeMove } from \"./executeMove\";\nexport default class Referee {\n  // promote(px: number, py: number, x : number, y: number, boardState : Piece []){\n  //     const piece = boardState.find(p => p.x === px && p.y === py)\n  //     if (piece && piece.type === PieceType.PAWN && piece.team === TeamType.WHITE && y === 7){\n  //         piece.promoted = true\n  //     }   \n  //     else if (piece && piece.type === PieceType.PAWN && piece.team === TeamType.BLACK && y === 0){\n  //         piece.promoted = true\n  //     } else if (piece){\n  //         piece.promoted = false\n  //     }\n  // } \n  takePiece(x, y, team, boardState) {\n    const piece = boardState.find(p => p.x === x && p.y === y && p.SuperPiece.team !== team);\n\n    if (piece) {\n      piece.taken = true;\n    }\n  }\n\n  endMove(px, py, x, y, team, boardState, valid, startingPawnMove, enPassant) {\n    if (!isFriendlyPiece(x, y, team, boardState)) {\n      executeMove(px, py, x, y, boardState);\n      const checker = new Checker(null);\n      console.log(team); // const inCheck = checker.isMyKingInCheck(team, boardState, 0)\n      // if (inCheck){\n      //     valid.value = false\n      // }  else {\n      //     valid.value = true\n      // }      \n    }\n  }\n\n  getPossiblePieces(px, py, x, y, piece, boardState, activePlayer) {\n    const possiblePieces = [];\n\n    if (!CLICKED) {\n      return possiblePieces;\n    } // Only the active player can move\n\n\n    if (piece.team !== activePlayer) {\n      return possiblePieces;\n    } // A non-move is not a move\n\n\n    if (px === x && py === y) {\n      return possiblePieces;\n    } // A move off the board is not a move\n\n\n    if (!(AXIS.includes(px) && AXIS.includes(py) && AXIS.includes(x) && AXIS.includes(y))) {\n      return possiblePieces;\n    }\n\n    var valid = {\n      value: false\n    };\n    const dx = x - px;\n    const dy = y - py;\n    const team = piece.team ? piece.team : TeamType.WHITE;\n    piece.subPieces.forEach(p => {\n      switch (p) {\n        case PieceType.PAWN:\n          {\n            if (isPawnStartingMove(px, py, x, y, team, boardState)) {\n              possiblePieces.push(PieceType.PAWN);\n            }\n\n            if (isPawnNormalMove(px, py, x, y, team, boardState)) {\n              if (!possiblePieces.includes(PieceType.PAWN)) {\n                possiblePieces.push(PieceType.PAWN);\n              }\n            }\n\n            break;\n          }\n\n        case PieceType.NIGHT:\n          {\n            if (isLegalNightMove(px, py, dx, dy, boardState)) {\n              possiblePieces.push(PieceType.NIGHT);\n            }\n\n            break;\n          }\n\n        case PieceType.BISHOP:\n          {\n            if (isLegalBishopMove(px, py, dx, dy, boardState)) {\n              possiblePieces.push(PieceType.BISHOP);\n            }\n\n            break;\n          }\n\n        case PieceType.ROOK:\n          {\n            if (isLegalRookMove(px, py, dx, dy, boardState)) {\n              possiblePieces.push(PieceType.ROOK);\n            }\n\n            break;\n          }\n\n        case PieceType.QUEEN:\n          {\n            if (isLegalQueenMove(px, py, dx, dy, boardState)) {\n              possiblePieces.push(PieceType.QUEEN);\n            }\n\n            break;\n          }\n\n        case PieceType.KING:\n          {\n            if (isLegalKingMove(px, py, dx, dy, boardState)) {\n              possiblePieces.push(PieceType.KING);\n            }\n\n            break;\n          }\n      }\n    });\n    return possiblePieces;\n  }\n\n}","map":{"version":3,"sources":["/home/jaybird/Coding Projects/QuantumChess/quantum-chess/src/Referee/referee.ts"],"names":["PieceType","TeamType","AXIS","isPawnNormalMove","isPawnStartingMove","isFriendlyPiece","isLegalBishopMove","isLegalRookMove","isLegalQueenMove","isLegalKingMove","isLegalNightMove","Checker","CLICKED","executeMove","Referee","takePiece","x","y","team","boardState","piece","find","p","SuperPiece","taken","endMove","px","py","valid","startingPawnMove","enPassant","checker","console","log","getPossiblePieces","activePlayer","possiblePieces","includes","value","dx","dy","WHITE","subPieces","forEach","PAWN","push","NIGHT","BISHOP","ROOK","QUEEN","KING"],"mappings":"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","sourcesContent":["/*\nThis class does a lot of the heavy lifting for the chess game.  Currently \nthe isValidMove also makes the move by changing the Piece [] as it checks for \nthe moves validity.  This is because once the move has been made it must use \nthe new board state to see if the move has put its own king in check which would \nactually make the move invalid.  So, if the move returns as invalid, the board \nstate must be reset. \n*/\n\n\nimport { PieceType, TeamType, Piece, AXIS } from \"../constants\"\nimport { isPawnNormalMove, isPawnStartingMove, isFriendlyPiece } from \"./pawnLogic\"\nimport { isLegalBishopMove, isLegalRookMove, isLegalQueenMove, isLegalKingMove, isLegalNightMove} from \"./pieceLogic\"\nimport Checker from './checker'\nimport {CLICKED} from '../components/Promotion/promotion'\nimport { executeMove } from \"./executeMove\"\nimport SuperPiece from \"../superPiece\"\n\nexport default class Referee{\n    \n\n\n    // promote(px: number, py: number, x : number, y: number, boardState : Piece []){\n    //     const piece = boardState.find(p => p.x === px && p.y === py)\n    //     if (piece && piece.type === PieceType.PAWN && piece.team === TeamType.WHITE && y === 7){\n    //         piece.promoted = true\n    //     }   \n    //     else if (piece && piece.type === PieceType.PAWN && piece.team === TeamType.BLACK && y === 0){\n    //         piece.promoted = true\n    //     } else if (piece){\n    //         piece.promoted = false\n    //     }\n    // } \n\n    takePiece(x : number, y: number, team : TeamType, boardState : Piece []){\n        const piece = boardState.find(p => p.x === x && p.y === y && p.SuperPiece.team !== team)  \n                if (piece) {\n            piece.taken = true\n        }\n    }\n\n    endMove(px : number, py : number, x : number, y: number, team : TeamType, \n            boardState : Piece [], valid : any, startingPawnMove: boolean, enPassant: boolean){\n        if (!isFriendlyPiece(x, y, team, boardState)){\n            executeMove(px, py, x, y, boardState)\n            const checker = new Checker(null);\n            console.log(team)\n            // const inCheck = checker.isMyKingInCheck(team, boardState, 0)\n            // if (inCheck){\n            //     valid.value = false\n            // }  else {\n            //     valid.value = true\n            // }      \n        }\n    }\n    getPossiblePieces(px : number, py : number, x : number, y : number, piece : SuperPiece, \n                boardState : Piece [],  activePlayer : TeamType) : PieceType [] {\n        const possiblePieces : PieceType [] = []; \n        if (!CLICKED){\n            return possiblePieces\n        }  \n        // Only the active player can move\n        if (piece.team !== activePlayer){\n            return possiblePieces\n        }\n        // A non-move is not a move\n        if (px === x && py === y){\n            return possiblePieces\n        }\n        // A move off the board is not a move\n        if (!(AXIS.includes(px) &&  AXIS.includes(py) &&  AXIS.includes(x) && AXIS.includes(y))){\n            return possiblePieces\n        }\n        var valid = { value: false }\n        const dx = x - px\n        const dy = y - py\n        const team = piece.team ? piece.team : TeamType.WHITE\n        piece.subPieces.forEach(p =>  {\n            switch(p){\n                case PieceType.PAWN : {\n                    if (isPawnStartingMove(px, py, x, y, team, boardState)){\n                        possiblePieces.push(PieceType.PAWN)\n                    }\n                    if (isPawnNormalMove(px, py, x, y, team, boardState)){\n                        if (!possiblePieces.includes(PieceType.PAWN)){\n                            possiblePieces.push(PieceType.PAWN)\n                        }\n                    }\n                    break;\n                }\n                case PieceType.NIGHT : {\n                    if (isLegalNightMove(px, py, dx, dy, boardState)){\n                        possiblePieces.push(PieceType.NIGHT)\n                    }\n                    break;\n                }\n                case PieceType.BISHOP : {\n                    if (isLegalBishopMove(px, py, dx, dy, boardState)){\n                        possiblePieces.push(PieceType.BISHOP)\n                    }\n                    break;\n                }\n                case PieceType.ROOK : {\n                    if (isLegalRookMove(px, py, dx, dy, boardState)){\n                        possiblePieces.push(PieceType.ROOK)\n                    }\n                    break;\n                }\n                case PieceType.QUEEN : {\n                    if (isLegalQueenMove(px, py, dx, dy, boardState)){\n                        possiblePieces.push(PieceType.QUEEN)\n                    }\n                    break;\n                }\n                case PieceType.KING : {\n                    if (isLegalKingMove(px, py, dx, dy, boardState)){\n                        possiblePieces.push(PieceType.KING)\n                    }\n                    break;\n                }\n\n            }\n        })\n    return possiblePieces\n    }\n}"]},"metadata":{},"sourceType":"module"}